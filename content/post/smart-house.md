---
title: "Умный дом своими руками"
author: "odvinc"
date: "2014-04-04"
topics: ["arduino", "development"]
tags: ["arduino", "development", "leonardo"]
description: "Умный дом на базе Arduino (Leonardo) и GSM модема"
aliases: ["/smart_house/"]
---

Эта статья о том как можно создать [&#171;Умный дом&#187;](http://ru.wikipedia.org/wiki/%D0%A3%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B4%D0%BE%D0%BC) своими руками с системой sms информирования владельца в случае нарушения периметра или срабатывания различных сенсоров.

Идея собрать и реализовать данную систему принадлежит моему отцу, за ним же и вся часть связанная с паяльником =) Я же, являюсь автором этой статьи и заказанного отцом кода, так как он пока не очень быстро научился писать программы для ардуинчика.

Ядром нашей системы будет выступать плата ввода-вывода [Arduino](http://arduino.cc/en/Main/Products "Arduino Products") (в нашем случае [Arduino Leonardo](http://arduino.cc/en/Main/ArduinoBoardLeonardo)), которая представляет из себя контроллер позволяющий достаточно легко обрабатывать цифровые и аналоговые сигналы и программировать логику в среде разработки на языке [Processing](http://ru.wikipedia.org/wiki/Processing)/Wiring (очень простой и понятный си подобный язык ).

<center>
[![Arduino Leonardo](/img/post/ArduinoLeonardoFront_2_400px.jpg "Arduino Leonardo")](http://arduino.cc/en/Main/ArduinoBoardLeonardo)  
<small>Arduino Leonardo</small>
</center>

<!--more-->

Заказать Arduino можно, например на [AliExpress](http://aliexpress.com). Стоимость за версию [Arduino Leonardo](http://arduino.cc/en/Main/ArduinoBoardLeonardo "Leonardo") у хорошего продавца, в среднем составляет 10$.

Для управления системой и смс информированием можно использовать практически любой GSM модем имеющий возможность обработки AT команд через последовательный порт. В качестве эталонного варианта предлагаю использовать [Arduino GSM Shield](http://arduino.cc/en/Main/ArduinoGSMShield). Мы же использовали имеющийся в наличии старенький Siemens MC35i Terminal.

<center>
![Siemens MC35i Terminal](/img/post/Siemens-MC35i-Terminal.jpg "Siemens MC35i Terminal")  
<small>Siemens MC35i Terminal</small>
</center>

Схему подключения пришлось немного доработать, так как потребовалось согласовать уровни. Для этого была использована микросхема [MAX232](http://ru.wikipedia.org/wiki/MAX232). Микросхему установили навесным монтажом, непосредственно внутри модема. Схема подключения аналогична <a title="Схема подключения MAX232" href="http://www.joyta.ru/7033-mikrosxema-max232-opisanie-sxema-vklyucheniya-datasheet/" target="_blank">этой</a>.

<center>
![Схема подключения MAX232](/img/post/mikrosxema-max232-opisanie-sxema-vklyucheniya-datasheet-4.gif "Схема подключения MAX232")  
<small>Схема подключения MAX232</small>
</center>

Для корректной работы модем должен находится в состоянии готовности. Перевести модем Siemens MC35i в готовность можно AT командами или подтянув к +5 вольт 7 ножку COM порта, через резистор в 100 Ом, как это сделали мы.

<center>
![Модем Siemens MC35i изнутри](/img/post/mc35i_max232.png "Модем Siemens MC35i изнутри")  
<small>Модем Siemens MC35i изнутри</small>
</center>


Исходный код, достаточно подробно документирован, фактически комментарий есть к каждой строке, чтобы  логика программы была понятна человеку не сильно сведущему в программировании, и в случае необходимости, каждый смог бы переделать программу под свои нужды.

Ссылка на исходный код доступна на <a title="Smart House" href="https://github.com/odvinc/smart_house" target="_blank">GitHub</a>. Там же можно найти несколько вариаций, в которых кнопка постановки на охрану и сенсоры логически инвертированы с 0 на 1. Одним из вариантов является SoftwareSerial - может пригодиться, тем кто будет использовать Arduino с одним последовательным портом и кто захочет переопределить контакты RX,TX на условно произвольные. Для выбора вариантов нужно нажимать на кнопочку branch, как показано на скриншете:

<center>![Select GitHub Branch](/img/post/select_branch.png "Select GitHub Branch")</center>

Основной вариант программы с использованием модема на порту COM1 (в коде Serial1) находится в branch: **master**. Загрузить скетч (так принято называть программы для arduino) целиком, можно нажав кнопку **&#171;Download ZIP&#187;**, в правом нижнем углу.

В файлике [at_sms.txt](https://github.com/odvinc/smart_house/blob/master/at_sms.txt "at_sms.txt") представлен типовой диалог инициализации модема и получения смс сообщения с текстом &#171;STATUS&#187;, к которому мы подключены терминалом через последовательный порт.

В файле [smart_house.ino](https://github.com/odvinc/smart_house/blob/master/smart_house.ino "smart_house.ino") находится непосредственно скетч.

Тем кому лень, детально изучать код программы и вникать в тонкости - расскажу, как примерно работает логика программы и как можно адаптировать ее под себя.

Прежде всего, хочу обратить внимание, что из фиксированного функционала в программу заложена только защита периметра. Для этого на определенный пин (в нашем примере это 12 pin) заведена секретная кнопка. После запуска arduino система ожидает ее нажатия, для инициализации постановки на охрану. В случае если инициализация произойдет, то она ожидает разрыв и замыкание периметра (открытие и закрытие двери), о чем сообщает кратковременными звуковыми сигналами с динамика (в нашем примере динамик расположен на 5 пине, а периметр отожествлен с пином номер 8). Как только произойдет закрытие двери, система встанет на охрану и будет ожидать, когда произойдет событие размыкание контура. После того как мы вернулись домой, и открыли дверь, система нам предоставит 10 секунд (параметр в функции `checkIFF(10)`) на нажатие  секретной кнопки. Если же мы этого не делаем или не успеваем в отведенное нам время, система отправляет смс сообщение на номер(а) хозяина, и переходит в режим аварийного звукового оповещения. Снять аварийный режим можно длительным 4х секундным нажатием на секретную кнопку.

В случае если срабатывают сенсоры, также приходит смс уведомление с информацией какой сенсор сработал и что произошло.

Большинство настроек, таких как номера пинов,  массивы для датчиков и устройств доступны в начале кода программы.

    // постоянные
    const int buttonPin = 12; // пин для кнопки
    const int perimeterPin = 8; // пин для периметра
    const int ledPin = 10 ; // пин индикатора
    const int sysledPin = 13; // пин системного индикатора
    const int tonePin = 5; // пин для динамика
    ...

Номера телефонов на которые будут отправляться смс уведомления задаются в массив  `smsNumbers[]` через запятую, по формату.

    char* smsNumbers[] = {"+79110000000", "+79630000000"}; // номера на которые необходимо отсылать аварийные сообщения
    ...

Если оставить массив пустым `smsNumbers[] = {};` то сообщения отправляться не будут, останутся только звуковое оповещения.

Аналогичным способом можно определить имеющиеся у вас сенсоры и устройства. Ниже пример определения двух сенсоров, - датчика протечки воды и утечки газа, где по порядку  определены: пин на котором находится сенсор, состояние сенсора и состояние аварии на момент инициализации arduino, название сенсора для смс уведомления, а также аварийное сообщение и сообщение по его локализации.

    // объявление сенсоров и их кодов ошибок
    tSensor mySensors[] = {
        { 6, false, false, "Water", "WARNING! Found water leakage.", "Water leakage disappeared." },
        { 3, false, false, "Gas", "WARNING! Found gas leakage.", "Gas leakage disappeared." }
    };
    ...

Также в программу заложена логика управления устройствами. В данном случае под устройствами понимается некий пин назначенный вами, к которому вы можете подключить реле или просто устанавливать логический ноль или единицу отправив команду по смс.

Устройства определяются точно таким же образом, как и сенсоры за небольшим исключением в формате записи массива.

Формат записи устройств: *[пин, состояние устройства на момент запуска, сенсорная кнопка или нет, название устройства для смс информирования]*

Пример:

    // объявление устройств и их состояний
    tDevice myDevices[] = {
        { 7, false, true, "Unit 1"},
        { 2, false, false, "Unit 2"}
    };
    ...

Третье по порядку значение, определяет тип кнопки устройства. Кнопка может быть &#171;сенсорной&#187;, т.е. при подаче команды на нее подается логическая 1 и 0 с интервалом в 1 сек, либо фиксированная, где - 1 всегда вкл,  а 0 выкл.

Управлять устройствами можно отправив sms сообщение следующего формата, на номер к которому подключена система:

[секретный код][0 или 1]...[0 или 1], где секретный код, это код заданный в начале программы, а 0 и 1 символизируют выключенное и включенное состояние соответственно:

    String secretStr = "7770:"; // кодовое слово для подачи команд по смс
    ...

т.е. например, чтобы включить первое устройство и выключить второе необходимо отправить смс сообщение следующего содержания &#171;**7770:10**&#187; . Количество параметров в смс, должно соответствовать количеству устройств в системе, в противном случае сообщение будет проигнорировано.

Если на номер системы отправить смс сообщение со словом &#171;**STATUS**&#187;, то в ответ вы получите примерно такое сообщение:

<center>![STATUS Message](/img/post/status_msg.png "STATUS Message")</center>

Можно пойти дальше и написать приложение, например для Android, но мы решили не заморачиваться =)

Вся отладочная информация дублируется на последовательный по умолчанию порт Serial. Этот же порт при желании можно задействовать для gsm модема, закомментировав  отладочный вывод.

P.S. При монтаже системы столкнулись с проблемой ложных срабатываний из-за достаточно большой длинны периметра. Как оказалось, бороться с этим достаточно просто установив несколько керамических конденсаторов по 5 вольтам Arduino.

Скачать среду разработки [Arduino IDE](http://arduino.cc/en/Main/Software) для вашей ОС можно по ссылке с официального сайта.
